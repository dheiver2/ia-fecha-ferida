const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');

class Database {
    constructor() {
        this.db = null;
        this.dbPath = path.join(__dirname, 'fecha_ferida.db');
        this.schemaPath = path.join(__dirname, 'schema.sql');
    }

    // Conectar ao banco (alias para initialize)
    async connect() {
        return await this.initialize();
    }

    // Inicializar conexão com o banco
    async initialize() {
        try {
            console.log('🗄️ Inicializando banco de dados SQLite...');
            
            // Criar diretório se não existir
            const dbDir = path.dirname(this.dbPath);
            if (!fs.existsSync(dbDir)) {
                fs.mkdirSync(dbDir, { recursive: true });
            }

            // Conectar ao banco
            this.db = new sqlite3.Database(this.dbPath, (err) => {
                if (err) {
                    console.error('❌ Erro ao conectar com o banco:', err.message);
                    throw err;
                }
                console.log('✅ Conectado ao banco SQLite:', this.dbPath);
            });

            // Habilitar foreign keys
            await this.run('PRAGMA foreign_keys = ON');
            
            // Executar schema se necessário
            await this.executeSchema();
            
            console.log('🎉 Banco de dados inicializado com sucesso!');
            return this.db;
        } catch (error) {
            console.error('❌ Erro ao inicializar banco:', error);
            throw error;
        }
    }

    // Executar schema do banco
    async executeSchema() {
        try {
            if (!fs.existsSync(this.schemaPath)) {
                console.warn('⚠️ Arquivo schema.sql não encontrado');
                return;
            }

            const schema = fs.readFileSync(this.schemaPath, 'utf8');
            console.log('📋 Executando schema do banco...');
            
            // Executar o schema completo usando exec para suportar múltiplas declarações
            await new Promise((resolve, reject) => {
                this.db.exec(schema, (err) => {
                    if (err) {
                        console.error('❌ Erro ao executar schema:', err);
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
            
            console.log('✅ Schema executado com sucesso');
        } catch (error) {
            console.error('❌ Erro ao executar schema:', error);
            throw error;
        }
    }

    // Executar query (Promise wrapper)
    run(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.run(sql, params, function(err) {
                if (err) {
                    console.error('❌ Erro na query:', err.message);
                    console.error('SQL:', sql);
                    reject(err);
                } else {
                    resolve({ id: this.lastID, changes: this.changes });
                }
            });
        });
    }

    // Buscar um registro
    get(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.get(sql, params, (err, row) => {
                if (err) {
                    console.error('❌ Erro na query:', err.message);
                    reject(err);
                } else {
                    resolve(row);
                }
            });
        });
    }

    // Buscar múltiplos registros
    all(sql, params = []) {
        return new Promise((resolve, reject) => {
            this.db.all(sql, params, (err, rows) => {
                if (err) {
                    console.error('❌ Erro na query:', err.message);
                    reject(err);
                } else {
                    resolve(rows);
                }
            });
        });
    }

    // Fechar conexão
    close() {
        return new Promise((resolve, reject) => {
            if (this.db) {
                this.db.close((err) => {
                    if (err) {
                        console.error('❌ Erro ao fechar banco:', err.message);
                        reject(err);
                    } else {
                        console.log('✅ Conexão com banco fechada');
                        resolve();
                    }
                });
            } else {
                resolve();
            }
        });
    }

    // Métodos de conveniência para usuários
    async createUser(userData) {
        const { email, password_hash, name, role = 'user', specialty, crm, institution, phone } = userData;
        
        const sql = `
            INSERT INTO users (email, password_hash, name, role, specialty, crm, institution, phone)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;
        
        return await this.run(sql, [email, password_hash, name, role, specialty, crm, institution, phone]);
    }

    async getUserByEmail(email) {
        const sql = 'SELECT * FROM users WHERE email = ? AND is_active = 1';
        return await this.get(sql, [email]);
    }

    async getUserById(id) {
        const sql = 'SELECT * FROM users WHERE id = ? AND is_active = 1';
        return await this.get(sql, [id]);
    }

    // Métodos para pacientes
    async createPatient(patientData) {
        const { 
            user_id, name, birth_date, gender, cpf, phone, email, 
            address, medical_history, allergies, current_medications,
            emergency_contact_name, emergency_contact_phone, notes 
        } = patientData;
        
        const sql = `
            INSERT INTO patients (
                user_id, name, birth_date, gender, cpf, phone, email,
                address, medical_history, allergies, current_medications,
                emergency_contact_name, emergency_contact_phone, notes
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        
        return await this.run(sql, [
            user_id, name, birth_date, gender, cpf, phone, email,
            address, medical_history, allergies, current_medications,
            emergency_contact_name, emergency_contact_phone, notes
        ]);
    }

    async getPatientsByUser(userId) {
        const sql = 'SELECT * FROM patients WHERE user_id = ? AND is_active = 1 ORDER BY name';
        return await this.all(sql, [userId]);
    }

    // Métodos para análises
    async createWoundAnalysis(analysisData) {
        const {
            user_id, patient_id, protocol_number, image_filename, image_path,
            lesion_location, patient_context, analysis_result, diagnosis_primary,
            diagnosis_confidence, severity, healing_potential, wound_length,
            wound_width, wound_depth, wound_area, processing_time
        } = analysisData;
        
        const sql = `
            INSERT INTO wound_analyses (
                user_id, patient_id, protocol_number, image_filename, image_path,
                lesion_location, patient_context, analysis_result, diagnosis_primary,
                diagnosis_confidence, severity, healing_potential, wound_length,
                wound_width, wound_depth, wound_area, processing_time, status
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'completed')
        `;
        
        return await this.run(sql, [
            user_id, patient_id, protocol_number, image_filename, image_path,
            lesion_location, JSON.stringify(patient_context), JSON.stringify(analysis_result),
            diagnosis_primary, diagnosis_confidence, severity, healing_potential,
            wound_length, wound_width, wound_depth, wound_area, processing_time
        ]);
    }

    async getAnalysesByUser(userId, limit = 50) {
        const sql = `
            SELECT wa.*, p.name as patient_name 
            FROM wound_analyses wa
            LEFT JOIN patients p ON wa.patient_id = p.id
            WHERE wa.user_id = ?
            ORDER BY wa.created_at DESC
            LIMIT ?
        `;
        return await this.all(sql, [userId, limit]);
    }

    // Deletar uma análise específica
    async deleteWoundAnalysis(analysisId, userId) {
        const sql = `
            DELETE FROM wound_analyses 
            WHERE id = ? AND user_id = ?
        `;
        return await this.run(sql, [analysisId, userId]);
    }

    // Deletar múltiplas análises
    async bulkDeleteWoundAnalyses(analysisIds, userId) {
        if (!Array.isArray(analysisIds) || analysisIds.length === 0) {
            throw new Error('Lista de IDs de análises é obrigatória');
        }

        const placeholders = analysisIds.map(() => '?').join(',');
        const sql = `
            DELETE FROM wound_analyses 
            WHERE id IN (${placeholders}) AND user_id = ?
        `;
        
        return await this.run(sql, [...analysisIds, userId]);
    }

    // Métodos para sessões
    async createSession(sessionData) {
        const { user_id, token_hash, device_info, ip_address, user_agent, expires_at } = sessionData;
        
        const sql = `
            INSERT INTO user_sessions (user_id, token_hash, device_info, ip_address, user_agent, expires_at)
            VALUES (?, ?, ?, ?, ?, ?)
        `;
        
        return await this.run(sql, [user_id, token_hash, device_info, ip_address, user_agent, expires_at]);
    }

    async getActiveSession(tokenHash) {
        const sql = `
            SELECT s.*, u.email, u.name, u.role 
            FROM user_sessions s
            JOIN users u ON s.user_id = u.id
            WHERE s.token_hash = ? AND s.is_active = 1 AND s.expires_at > datetime('now')
        `;
        return await this.get(sql, [tokenHash]);
    }

    async invalidateSession(tokenHash) {
        const sql = 'UPDATE user_sessions SET is_active = 0 WHERE token_hash = ?';
        return await this.run(sql, [tokenHash]);
    }

    // Log de auditoria
    async logAction(logData) {
        const { user_id, action, resource_type, resource_id, details, ip_address, user_agent } = logData;
        
        const sql = `
            INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details, ip_address, user_agent)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        `;
        
        return await this.run(sql, [
            user_id, action, resource_type, resource_id, 
            JSON.stringify(details), ip_address, user_agent
        ]);
    }
}

// Singleton instance
let dbInstance = null;

class DatabaseManager {
    static getInstance() {
        if (!dbInstance) {
            dbInstance = new Database();
        }
        return dbInstance;
    }

    static async getDatabase() {
        if (!dbInstance) {
            dbInstance = new Database();
            await dbInstance.initialize();
        }
        return dbInstance;
    }
}

module.exports = DatabaseManager;